# Output Consumption

## Background

Once the asset has been tasked, Herd-Server collects all the output lines produced by the executed commands and wraps them in custom Socket.IO messages.

Thanks to the real-time, bidirectional and event-based communication enabled by Socket.IO, the output flow is offered asynchronously through the WebSocket protocol. This system uses a custom and fixed format in order to encapsulate two categories of messages: the **keepalive** messages providing a real-time status of the assets, and the **informative** messages containing the tasks results. This template standardizes the data flow generated by each entity available in RedHerd.

<img src="framework_message.png" style="display: block; margin-left: auto; margin-right: auto; width: 95%;" alt="RedHerd">

## Specifications

The messages are based on two different layers which are briefly summarized in the followig tables.

**Layer 1**

| Field | Description |
| --- | --- |
| `source` | The generating entity of the message |
| `destination` | The destination entity of the message |
| `type` | A message content indicator (e.g. `gen_res` for general information, `cmd_res` for command outcomes, `syn_res` for File-Server sync result) |
| `session` | The `sessionid` assigned to the specific output flow |
| `payload` | The second layer envelope |


**Layer 2**

| Field | Description |
| --- | --- |
| `id` | The unique identifier assigned to the current message |
| `type` | A message stream indicator (e.g. `stdout`, `stderr`, `extcode`) |
| `timestamp` | The date and time of the message creation |
| `content` | The informative value of the message |

The output is sent asynchronously using an Out-of-Band (OoB) channel which is exposed by Herd-Server on port `3001` using primarily the `wss` protocol. As shown, each message is tagged with a specific `sessionid` representing a unique identifier needed by the requesting entity to link it with the generating task.

## Hands-on

The following examples provide a starting point useful to understand the output dispatching process that RedHerd implements.

In addition, the JavaScript code written below is an example of how to connect to the OoB channel and consume the output flow.

```js
const io = require("socket.io-client");

var socket = io("wss://10.10.0.3:3001", { rejectUnauthorized : false });

socket.on("message", function(message) {
    console.log(message); 
});
```

Assuming `redherd_socketio_client.js` as the name of this script, it could be executed launching `node` in a `bash` command line.

```bash
$ node ./redherd_socketio_client.js
```
### Example 1. Get assets status

This example shows how to process the **keepalive** messages which are broadcasted periodically by Herd-Server and contain an indication of reachability for all the assets joined.

```bash
$ node ./redherd_socketio_client.js
{
  src: '1',
  dst: 'keep_alive',
  type: 'gen_res',
  session: '0',
  payload: {
    id: '40b49dd822f239e30905b95989491f1e',
    type: 'STDOUT',
    timestamp: 1626092845229,
    content: 'asset-hostname'
  }
}
```

!!! note
    In the example described above, the `sessionid` is set to zero because the message is broadcasted and it is not referred to any task.

### Example 2. Consume module output

This second example shows how to process the **informative** messages containing the `stdout` or the `stderr` generated by the execution of a module.

```bash
$ curl -X POST --insecure -i -H "Content-Type: application/json" -d '{"mode":"execute","params":{"target":"www.fakesite.local"}}' "https://10.10.0.3:3000/api/assets/1/modules/debian_ping/run?t=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vy [...] KDP4jvyBA"
HTTP/1.1 200 OK
X-Powered-By: Express
Content-Type: application/json; charset=utf-8
Content-Length: 101
Date: Mon, 12 Jul 2021 13:03:48 GMT

{
    "status": "success",
    "data": {
        "instance": {
            "session": "b192f130a8bd315195b24faf480198de",
            "result": null
        }
    }
}
```

```bash
$ node ./redherd_socketio_client.js
{
  src: '1',
  dst: 'debian_ping',
  type: 'cmd_res',
  session: 'b192f130a8bd315195b24faf480198de',
  payload: {
    id: '7faf97afb9374532e6116593e2c2a0d5',
    type: 'STDOUT',
    timestamp: 1626095028365,
    content: 'PING www.fakesite.local (127.0.1.1) 56(84) bytes of data.\n' +
      '64 bytes from www.fakesite.local (127.0.1.1): icmp_seq=1 ttl=64 time=0.022 ms'
  }
}
{
  src: '1',
  dst: 'debian_ping',
  type: 'cmd_res',
  session: 'b192f130a8bd315195b24faf480198de',
  payload: {
    id: 'ed2e6c568557de5b3fc1cf759429a900',
    type: 'STDOUT',
    timestamp: 1626095029390,
    content: '64 bytes from www.fakesite.local (127.0.1.1): icmp_seq=2 ttl=64 time=0.080 ms'
  }
}
{
  src: '1',
  dst: 'debian_ping',
  type: 'cmd_res',
  session: 'b192f130a8bd315195b24faf480198de',
  payload: {
    id: '04b5b4fcfb31b5c696080f3dd0238407',
    type: 'STDOUT',
    timestamp: 1626095030413,
    content: '64 bytes from www.fakesite.local (127.0.1.1): icmp_seq=3 ttl=64 time=0.049 ms'
  }
}
{
  src: '1',
  dst: 'debian_ping',
  type: 'cmd_res',
  session: 'b192f130a8bd315195b24faf480198de',
  payload: {
    id: '0a2b3e32f0c43b8315d4633841086c22',
    type: 'STDOUT',
    timestamp: 1626095031436,
    content: '64 bytes from www.fakesite.local (127.0.1.1): icmp_seq=4 ttl=64 time=0.034 ms\n' +
      '\n' +
      '--- www.fakesite.local ping statistics ---\n' +
      '4 packets transmitted, 4 received, 0% packet loss, time 3071ms\n' +
      'rtt min/avg/max/mdev = 0.022/0.046/0.080/0.021 ms'
  }
}
{
  src: '1',
  dst: 'debian_ping',
  type: 'cmd_res',
  session: 'b192f130a8bd315195b24faf480198de',
  payload: {
    id: '97eafe81bd9860db05d482573187c893',
    type: 'EXTCODE',
    timestamp: 1626095031438,
    content: '0'
  }
}
```

!!! note
    The value of the `content` field provided by the closing message is the `exit-code` of the application launched, so it could be used to catch possible execution errors.
